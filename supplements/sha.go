package supplements

import (
	"fmt"
	"github.com/whitesource/log4j-detect/hash"
	rc "github.com/whitesource/log4j-detect/records"
	"strings"
)

var lower = strings.ToLower

// sha - this method is the main entry of this module
// this method is responsible to generate a sha of the library
// based on the desired calculation methodology specified in SHAMethod
// inputs : *utils.Library - the library instance to generate sha for
// inputs : SHAMethod the desired sha method to be used to calculate sha
// returns : string representation of the lib , error indicating an error if occurs
func sha(lib rc.Library, m HashMethod) (string, error) {
	if err := m.Validate(lib); err != nil {
		return "", err
	}
	return m.Hash(lib), nil
}

// HashMethod represents the methods used to calculate the additional sha1 for a library
type HashMethod interface {
	// Validate returns an error if this library is not valid for hashing
	Validate(lib rc.Library) error

	// Hash returns the additional sha1 for this library
	Hash(lib rc.Library) string
}

// HashMethod types
type (
	// gavt Group Artifact Version Type
	gavt struct{}

	// gavtlc Group Artifact Version Type (Lower Case, Not Including Type)
	gavtlc struct{}

	// avt Artifact Version Type
	avt struct{}

	// act Artifact Commit Type
	act struct{}

	// avtlc Artifact Version Type (Lower Cased, Not Including Type)
	avtlc struct{}

	// avtlca Artifact Version Type (Artifact Lower Cased, Not Including Type)
	avtlca struct{}
)

func (gavtlc) Validate(lib rc.Library) error {
	return validateGAVT(lib)
}

func (gavtlc) Hash(lib rc.Library) string {
	return underscoreSha1(lower(lib.GroupId), lower(lib.Artifact), lower(lib.Version), lib.LType.String())
}

func (gavt) Validate(lib rc.Library) error {
	return validateGAVT(lib)
}

func (gavt) Hash(lib rc.Library) string {
	return underscoreSha1(lib.GroupId, lib.Artifact, lib.Version, lib.LType.String())
}

func (avtlc) Validate(lib rc.Library) error {
	return validateAVT(lib)
}

func (avtlc) Hash(lib rc.Library) string {
	return underscoreSha1(lower(lib.Artifact), lower(lib.Version), lib.LType.String())
}

func (avt) Validate(lib rc.Library) error {
	return validateAVT(lib)
}

func (avt) Hash(lib rc.Library) string {
	return underscoreSha1(lib.Artifact, lib.Version, lib.LType.String())
}

func (act) Validate(lib rc.Library) error {
	return validateACT(lib)
}
func (act) Hash(lib rc.Library) string {
	return underscoreSha1(lib.Artifact, lib.Commit, lib.LType.String())
}

func (avtlca) Validate(lib rc.Library) error {
	return validateAVT(lib)
}

func (avtlca) Hash(lib rc.Library) string {
	return underscoreSha1(lower(lib.Artifact), lib.Version, lib.LType.String())
}

// validateGAVT - this method validates the library's GAV coordinates
// input: library instance
// return : error in case of non-valid (empty coordinate) , nil otherwise
func validateGAVT(lib rc.Library) error {
	if len(lib.GroupId) == 0 || len(lib.Artifact) == 0 ||
		len(lib.Version) == 0 || len(lib.LType.String()) == 0 {
		return fmt.Errorf("failed to validate library GAV for sha1")
	}
	return nil
}

// validateAVT - this method validates the library's AV coordinates
// input: library instance
// return : error in case of non-valid (empty coordinate) , nil otherwise
func validateAVT(lib rc.Library) error {
	if len(lib.Artifact) == 0 || len(lib.Version) == 0 ||
		len(lib.LType.String()) == 0 {
		return fmt.Errorf("failed to validate library AVT for sha1")
	}
	return nil
}

// validateACT - this method validates the library's AC coordinates
// input: library instance
// return : error in case of non-valid (empty coordinate) , nil otherwise
func validateACT(lib rc.Library) error {
	if len(lib.Artifact) == 0 || len(lib.Commit) == 0 ||
		len(lib.LType.String()) == 0 {
		return fmt.Errorf("failed to validate library ACT for sha1")
	}
	return nil
}

// underscoreSha1 a hash of the string generated by joining all provided strings with an underscore,
// and calculating its sha1
func underscoreSha1(elems ...string) string {
	return hash.StringSha1(strings.Join(elems, "_"))
}
